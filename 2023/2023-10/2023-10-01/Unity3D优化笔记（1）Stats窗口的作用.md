---
title: Unity3D优化笔记（1）Stats窗口的作用
math: true
date: 2023-10-01 23:54:24
categories:
 - [Unity3D]
tags: 
 - Unity3D
---

![](https://image.aayu.today/uploads/2023/10/01/202310012355561.png)

通过 Stats 窗口可以初步查看游戏运行时，当前一帧的各项性能。

Stats 是英文单词 Statistics 的缩写，意思是“统计数据”。

打开方法：Game 窗口右上角，找到 Stats，点击它。

## Unity 绘制调用（Draw Call）、批次（Batch）

要将游戏中的物体显示到屏幕上，就需要绘制它们。绘制之前，会先由 CPU 计算出它们的位置、颜色等信息，然后发送绘制指令给 GPU。GPU 接受到 CPU 发过来的绘制指令，就会按照要求绘制东西在屏幕上。

Draw Call 是指 CPU 向 GPU 发送绘制指令的过程，==一个 Draw Call 就是 CPU 向 GPU 发送的一组绘制指令==，可以绘制出一个或多个物体。

Draw Call 有时也被简称为 DC

Draw Call 太多会使游戏变卡，优化的时候可以想办法降低 Draw Call。

要降低 Draw Call，可以使用合批技术，例如动态合批和静态合批。将多个 Draw Call 合批成一个批次（Batch），再由 CPU 发送给 GPU，这样可以提升游戏性能。

## Audio 表示音频的数据

* Level 表示==声音强度==，单位是分贝，也就是 dB。声音太大或太小都会影响玩家体验。

  * 应将这项数据控制在一个合适的范围内。
* DSP load 表示==数字信号处理器的负载==。播放的声音越多、声音的采样率越高、声音效果越复杂，本变量的数值都会越大。

  * 应尽量避免这项数据过大。
* Clipping 表示==音频的裁剪情况==。当音频信号超过设备支持的最大范围时，该音频信号会被裁剪。裁剪之后，该音频会出现一定程度失真的现象。

  * 应尽量避免这项数据过大。
* Stream load 表示==音频流的负载情况==。音频的流式加载是指以持续的方式从音频源获取音频数据，而不是一次性加载全部数据。流式加载的主要优势是可以实时地处理和播放音频，无需等待全部数据加载完成。

  * 应尽量避免这项数据过大。

## Graphics 表示图像的数据

* FPS 表示==帧率==，也就是 1 秒内播放多少帧。可以用来判断游戏运行得是否流畅。

  * 例如 209.5FPS（4.8ms）表示平均每秒播放 209.5 张画面，平均每 4.8 毫秒播放一张画面。
  * 游戏画面、视频画面都是由一张张静态的画面连续播放而成的，1 帧就是一张静态的画面。60FPS 是很流畅的，45FPS 比较流畅，30FPS 会明显感到卡顿。
  * 应将这项数据控制在一个合适的范围内。
* CPU 的指标表示 ==CPU 处理一帧的时间==。

  * 例如 CPU:main 4.6ms render thread 0.5ms 表示 Unity 的主线程处理这一帧所花费的时间是 4.6 毫秒，主线程主要负责游戏逻辑的更新，例如检测用户的输入、更新游戏对象的位置、碰撞检测等。在渲染线程处理这一帧所花费的时间是 0.5 毫秒，渲染线程负责显示游戏画面。
  * 应尽量避免这项数据过大。
* Batches 表示==处理的绘制调用（Draw Call）批次的总数==。

  * 应尽量避免这项数据过大。
* Saved by batching 表示==有多少个绘制调用（Draw Call）被合并到了批次==。

  * 应尽量让这项数据大。
* Tris 表示==当前摄像机视锥体的范围内三角面的个数==。

  * 应尽量避免这项数据过大。
* Verts 表示==当前摄像机视锥体的范围内网格顶点的个数==。

  * 应尽量避免这项数据过大。
  * 在 3D 建模软件中创建的模型导入到 Unity 后，该模型在 Unity 中显示的三角面和网格顶点的数量和在 3D 建模软件中的可能不同。因为 3D 建模软件和 Unity 对模型的三角面和网格顶点的计算方式可能是不一样的。
* Screen 表示==当前的屏幕分辨率==，以及==屏幕的内存占用量==。例如 Screen：1920×1080 - 23.7MB 表示当前屏幕分辨率是 1920×1080，屏幕占用了 23.7MB 的内存。

  * 应尽量避免这项数据过大。
* SetPass calls 表示==在当前摄像机的渲染过程中，Unity 切换着色器通道（Shader Pass）来渲染游戏对象的次数==。一个着色器（Shader）可以包含多个着色器通道，每个着色器通道可以通过不同的方式来渲染游戏对象。**但每次切换着色器通道都会消耗一定的性能**。

  * 应尽量避免这项数据过大。
* Shadow casters 表示==摄像机画面中有多少个游戏对象产生了阴影==。同一个游戏对象产生较多的阴影，可能会被算作多个 Shadow casters

  * 应尽量避免这项数据过大。
* Visible skinned meshes 表示==当前摄像机中有多少个可见的蒙皮网格==。网格用来定义一个模型的形状、大小和表面细节等信息，模型的所有顶点、线、面共同构成了这个模型的网格。蒙皮网格是一个与骨骼绑定的网格，这个网格可以发生形变和做出各种动作。一个网格在没有蒙皮之前是不能发生形变的，也不能做出各种动作的。但是在成功蒙皮之后，这个网格就可以发生形变和做出各种动作。

  * 应尽量避免这项数据过大。
* Animator components playing 表示==当前场景中有多少个 Animator 组件正在播放动画==。播放动画会消耗性能。

  * 应尽量避免这项数据过大。
* Animation components playing 表示==当前场景中有多少个 Animation 组件正在播放动画==。播放动画会消耗性能。

  * 应尽量避免这项数据过大。
  * **没用的 Animator 组件和 Animation 组件可以考虑删掉。因为即使只有空的动画，Animator 组件和 Animation 组件也会根据自己的工作流程进行每帧的计算和更新，以检查当前动画状态和过渡条件，这样就会消耗不必要的性能。**

‍
